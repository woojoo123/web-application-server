# 실습을 위한 개발 환경 세팅
* https://github.com/slipp/web-application-server 프로젝트를 자신의 계정으로 Fork한다. Github 우측 상단의 Fork 버튼을 클릭하면 자신의 계정으로 Fork된다.
* Fork한 프로젝트를 eclipse 또는 터미널에서 clone 한다.
* Fork한 프로젝트를 eclipse로 import한 후에 Maven 빌드 도구를 활용해 eclipse 프로젝트로 변환한다.(mvn eclipse:clean eclipse:eclipse)
* 빌드가 성공하면 반드시 refresh(fn + f5)를 실행해야 한다.

# 웹 서버 시작 및 테스트
* webserver.WebServer 는 사용자의 요청을 받아 RequestHandler에 작업을 위임하는 클래스이다.
* 사용자 요청에 대한 모든 처리는 RequestHandler 클래스의 run() 메서드가 담당한다.
* WebServer를 실행한 후 브라우저에서 http://localhost:8080으로 접속해 "Hello World" 메시지가 출력되는지 확인한다.

# 각 요구사항별 학습 내용 정리
* 구현 단계에서는 각 요구사항을 구현하는데 집중한다. 
* 구현을 완료한 후 구현 과정에서 새롭게 알게된 내용, 궁금한 내용을 기록한다.
* 각 요구사항을 구현하는 것이 중요한 것이 아니라 구현 과정을 통해 학습한 내용을 인식하는 것이 배움에 중요하다. 

### 요구사항 1 - http://localhost:8080/index.html로 접속시 응답
새로 알게 된 점
사용자 1명이 접속했다고 요청이 1개만 오는 게 아니었다. 브라우저는 화면을 그릴 때 HTML 하나만 받는 게 아니라, 그 HTML이 필요로 하는 리소스들을 같이 받아야 한다. 대표적으로 CSS, JS, 이미지, 그리고 거의 습관처럼 붙는 favicon.ico 같은 것들이다. 그래서 브라우저는 페이지를 제대로 렌더링하기 위해 여러 리소스를 동시에 요청한다.

동시에 요청한다는 말은 결국 네트워크 레벨에서 여러 TCP 연결을 병렬로 열 수 있다는 뜻이다. 브라우저는 성능 때문에 요청을 순서대로 한 줄로 보내기보단, 가능한 범위에서 여러 연결(또는 여러 요청)을 동시에 돌려서 빨리 받아온다. 그 결과 서버 입장에선 거의 같은 시간에 연결이 여러 개 들어오고, 내 서버 코드는 “연결 하나당 RequestHandler를 만들고 start()로 새 쓰레드를 띄우는 구조”라서 요청 개수만큼 쓰레드가 생기고 로그도 여러 줄로 찍힌다.
즉, 체감적으로는 “사용자 1명 = 요청 1개”가 아니라, **“사용자 1명 = 여러 요청(병렬 가능)”**이 맞다.

그리고 여기서 또 하나 헷갈렸던 부분이 “요청을 보낸다”의 의미였다. 요청을 보낸다는 건 “그냥 URL을 호출한다”가 아니라, 정확히는 이미 연결된 소켓(TCP 연결) 위에 HTTP 데이터를 흘려보내는 것이다.

이미 연결이 살아있으면: 그 연결(Socket)의 OutputStream으로 HTTP 요청 바이트를 보내면 된다.

연결이 없으면: 먼저 TCP 연결을 새로 만들고(Socket 생성 + 연결 성립), 그 위에 HTTP 요청을 보낸다.

근데 내가 만든 서버는 지금 구조상 요청을 한 번 처리하고 나면 연결을 끊는(닫는) 쪽에 가깝다. (try-with-resources로 스트림/소켓 자원을 정리하고 끝나버리는 구조) 그러니까 브라우저가 CSS, 이미지 같은 다음 리소스를 요청할 때, 기존 연결을 재사용하기 어렵고 요청마다 새 소켓을 만드는 것처럼 보이게 된다. 실제로는 “요청마다 새 연결이 생겼다”라기보단, “서버가 연결을 오래 유지하지 않으니 결과적으로 새 연결이 계속 생긴다”에 가깝다.

정리하면 이렇다.

브라우저는 페이지 렌더링을 위해 여러 리소스를 동시에 요청한다. (HTML, CSS, JS, 이미지, favicon 등)

동시에 요청하려고 여러 TCP 연결을 병렬로 열 수 있고, 서버는 연결마다 RequestHandler 쓰레드를 만들기 때문에 Thread가 여러 개 찍힌다.

“요청을 보낸다”는 건 소켓 연결 위로 HTTP 데이터를 보내는 것이다.

연결이 없으면 먼저 TCP 연결을 만들고 요청을 보내는데,

내 서버는 요청 1개 처리 후 연결을 종료하는 구조라서 브라우저가 리소스 요청을 할 때마다 새 소켓이 계속 생기는 것처럼 보였다.

이걸 이해하고 나니까, 로그에 /index.html 다음에 /favicon.ico가 따라오고, 그때마다 Thread가 새로 찍히는 게 오히려 자연스럽게 보이기 시작했다.

### 요구사항 2 - get 방식으로 회원가입
* 

### 요구사항 3 - post 방식으로 회원가입
* 

### 요구사항 4 - redirect 방식으로 이동
* 

### 요구사항 5 - cookie
* 

### 요구사항 6 - stylesheet 적용
* 

### heroku 서버에 배포 후
* 